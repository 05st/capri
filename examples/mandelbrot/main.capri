module main;

extern c_f64_add(f64, f64): f64;
extern c_f64_sub(f64, f64): f64;
extern c_f64_mul(f64, f64): f64;
extern c_f64_gt(f64, f64): bool;
extern c_f64_lt(f64, f64): bool;

extern c_bool_or(bool, bool): bool;
extern c_bool_and(bool, bool): bool;

import prelude;

op infixl 5 +.(a: f64, b: f64): f64     c_f64_add(a, b);
op infixl 5 -.(a: f64, b: f64): f64     c_f64_sub(a, b);
op infixl 10 *.(a: f64, b: f64): f64    c_f64_mul(a, b);
op infixl 4 >.(a: f64, b: f64): bool    c_f64_gt(a, b);
op infixl 4 <.(a: f64, b: f64): bool    c_f64_lt(a, b);

op infixl 1 ||(a: bool, b: bool): bool  c_bool_or(a, b);
op infixl 2 &&(a: bool, b: bool): bool  c_bool_and(a, b);

fn pd(d: f64): unit {
    if d >. 8.0
        print("#")
    else if d >. 4.0
        print("+")
    else if d >. 2.0
        print(".")
    else
        print(" ");
};

fn converge(cr, ci) {
    let mut r = 0.0;
    let mut i = 0.0;
    let mut r2 = 0.0;
    let mut i2 = 0.0;
    let mut iters = 0.0;
    while (r2 +. i2 <. 4.0) && (iters <. 256.0) {
        i = r *. i *. 2.0 +. ci;
        r = r2 -. i2 +. cr;
        r2 = r *. r;
        i2 = i *. i;
        iters = iters +. 1.0;
    };
    iters
};

fn plot(xmin, xmax, xstep, ymin, ymax, ystep) {
    let mut y = ymin;
    while y <. ymax {
        let mut x = xmin;
        while x <. xmax {
            pd(converge(x, y));
            x = x +. xstep;
        };
        print("\n");
        y = y +. ystep;
    };
};

fn main() {  
    let rs = -2.5;
    let is = -1.3;
    let rm = 0.05;
    let im = 0.07;

    plot(rs, rs +. rm *. 78.0, rm, is, is +. im *. 40.0, im);
};